# [堆排序JAVA实现](https://blog.csdn.net/qq_35181209/article/details/66544974)

1.原理：
堆是一种完全二叉树：每个节点的值大于或者等于自己的左右子节点，称为最大堆
    每个节点的值小于或者等于自己的左右子节点，称为最小堆

这里讲最大堆。

排序两个步骤：

（1）由一个无序序列建成一个最大堆；

（2）堆顶元素和末尾元素交换，输出堆顶元素后，调整剩余元素为一个新的最大堆

---------------------

2.源码实现
具体的分析每句代码都带明确解释。

```java
public class HeapSort {
	//adjustIndex为每次要调整的节点对应数组的索引，len表示每次所有调整的节点总数
	public void adjust(int[] a, int adjustIndex, int len){
		//保存要调整的节点，以便后面交换
		int temp = a[adjustIndex];
		//索引从0开始，所以子节点索引是adjustIndex*2+1
		for(int i = adjustIndex*2+1; i < len; i=2*i+1){
			//比较左节点和右节点，更新最大对应i
			if(i < len-1 && a[i] < a[i+1]) i++;
			//无需调整，直接跳出循环
			if(temp >= a[i]) break;
			//更新，同时保存替换父节点的子节点索引
			a[adjustIndex] = a[i];
			adjustIndex = i;
		}
		//将父节点赋值给最后一个调换的子节点
		a[adjustIndex] = temp;
	}
	public void HeapSort(int[] a){
		//进行第一次最大堆建立过程，对所有的非叶子节点（从下到上，从右到左）进行调整，
		//具有n个节点的完全二叉树，所有的非叶子索引从0开始，到n/2-1
		for(int i = a.length/2-1; i >= 0; i--){
			adjust(a, i, a.length);
		}
		//每次建立一个最大堆后，将根节点与最大堆最末尾一个节点进行调换
		//接着去掉这个最大末尾值，剩下所有的节点继续对根节点进行最大堆调整
		for(int i = a.length-1; i > 0; i--){
			swap(a, 0, i);
			adjust(a, 0, i);
		}
	}
	//交换
	public void swap(int[] a, int i, int j){
		int temp = a[i];
		a[i] = a[j];
		a[j] = temp;
	}
}
```



3.时间复杂度分析 
堆排序的时间复杂度，主要在初始化堆过程和每次选取最大数后重新建堆的过程；

（1） 初始化建堆过程时间：O(n)（这个分析的很好，特意转载点击打开链接）

        推算过程：
    
        首先要理解怎么计算这个堆化过程所消耗的时间，可以直接画图去理解；
    
        假设高度为k，则从倒数第二层右边的节点开始，这一层的节点都要执行子节点比较然后交换（如果顺序是对的就不用交换）；倒数第三层呢，则会选择其子节点进行比较和交换，如果没交换就可以不用再执行下去了。如果交换了，那么又要选择一支子树进行比较和交换；
    
        那么总的时间计算为：s = 2^( i - 1 )  *  ( k - i )；其中 i 表示第几层，2^( i - 1) 表示该层上有多少个元素，( k - i) 表示子树上要比较的次数，如果在最差的条件下，就是比较次数后还要交换；因为这个是常数，所以提出来后可以忽略；
    
        S = 2^(k-2) * 1 + 2^(k-3)*2.....+2*(k-2)+2^(0)*(k-1)  ===> 因为叶子层不用交换，所以i从 k-1 开始到 1；
    
        这个等式求解，我想高中已经会了：等式左右乘上2，然后和原来的等式相减，就变成了：
    
        S = 2^(k - 1) + 2^(k - 2) + 2^(k - 3) ..... + 2 - (k-1)
    
        除最后一项外，就是一个等比数列了，直接用求和公式：S = {  a1[ 1-  (q^n) ] }  / (1-q)；
    
        S = 2^k -k -1；又因为k为完全二叉树的深度，所以 (2^k) <=  n < (2^k  -1 )，总之可以认为：k = logn （实际计算得到应该是 log(n+1) < k <= logn ）;
    
        综上所述得到：S = n - logn -1，所以时间复杂度为：O(n)

（2） 每次选取最大数后重新建堆过程时间：O(nlogn)   

n-1次堆顶记录，每次最多logn的时间，因为二叉树的深度为logn，所以复杂度为O(nlogn)  

4.空间复杂度
因为只有一个用来交换的临时单元，所以空间复杂度为O(1)。
5.特殊注意
（1）由于记录的比较和交换是跳跃式进行，所以是一种不稳定的排序方法
（2）由于初始构建堆所需的比较次数比较多，因为它并不适合待排序序列个数较少的情况。 

---------------------