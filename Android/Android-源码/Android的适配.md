### 前言

Android的适配是可以分两个大块的，一个是关于系统版本方面的适配，这个不仅是原生的系统版本，还有我们的各家厂商的ROM的适配，现在最主流的两种屏幕适配方案，今日头条适配方案 和 smallestWidth 限定符适配方案

什么是宽高限定符适配呢

```
├── src/main
│   ├── res
│   ├── ├──values
│   ├── ├──values-800x480
│   ├── ├──values-860x540
│   ├── ├──values-1024x600
│   ├── ├──values-1024x768
│   ├── ├──...
│   ├── ├──values-2560x1440
```

就是这种，在资源文件下生成不同分辨率的资源文件，然后在布局文件中引用对应的 **dimens **

## 一、英寸

一般用英寸描述屏幕的物理大小，如电脑显示器的 `17`、 `22`，手机显示器的 `4.8`、 `5.7`等使用的单位都是英寸。

英寸( `inch`,缩写为 `in`)在荷兰语中的本意是大拇指，一英寸就是指甲底部普通人拇指的宽度。

英寸和厘米的换算： `1英寸=2.54厘米`

## 二、分辨率

### 2.1 像素

像素即一个小方块，它具有特定的位置和颜色。

图片、电子屏幕（手机、电脑）就是由无数个具有特定颜色和特定位置的小方块拼接而成。

像素可以作为图片或电子屏幕的最小组成单位。

### 2.2 屏幕分辨率

屏幕分辨率指一个屏幕具体由多少个像素点组成。

`iPhone XSMax` 和 `iPhone SE`的分辨率分别为 `2688x1242`和 `1136x640`。这表示手机分别在垂直和水平上所具有的像素点数。

当然分辨率高不代表屏幕就清晰，屏幕的清晰程度还与尺寸有关。

### 2.3 图像分辨率

我们通常说的 `图片分辨率`其实是指图片含有的 `像素数`，比如一张图片的分辨率为 `800x400`。这表示图片分别在垂直和水平上所具有的像素点数为 `800`和 `400`。

同一尺寸的图片，分辨率越高，图片越清晰。

### 2.4 PPI

`PPI(PixelPerInch)`：每英寸包括的像素数。

`PPI`可以用于描述屏幕的清晰度以及一张图片的质量。 `PPI`越高，图片质量越高，使用 `PPI`描述屏幕时， `PPI`越高，屏幕越清晰。

### 2.5 DPI

`DPI(DotPerInch)`：即每英寸包括的点数。

这里的点是一个抽象的单位，它可以是屏幕像素点、图片像素点也可以是打印机的墨点。

平时你可能会看到使用 `DPI`来描述图片和屏幕，这时的 `DPI`应该和 `PPI`是等价的， `DPI`最常用的是用于描述打印机，表示打印机每英寸可以打印的点数。

一张图片在屏幕上显示时，它的像素点数是规则排列的，每个像素点都有特定的位置和颜色。



前期，由于公司支持的平板款式单一，只需要做几款平板的适配即可，选用了 smalledtWidth(最小宽度)适配，但是这个方案在增加新屏幕时且原 dimens 文件无法很好适配时，就需要增加新屏幕的最小宽度 dimens 文件了，比较麻烦而且会增加项目大小(虽然只是几个文件)，而且这种屏幕适配极度依赖设备的屏幕密度，叫density。为了讲解更清楚，这里需要引入几个公式：

> > **px = density \* dp**
> > dp : 安卓开发人员常常挂在嘴上的长度单位
> > px : 设计人员眼中的长度单位
> > **density = dpi / 160**
> > 因此，**px = dp \* (dpi/160)**
> > dpi : 根据屏幕真实分辨率和尺寸计算得出
> > 举个例子：屏幕分辨率为 1920 * 1080，屏幕尺寸为5寸(屏幕斜边长度cm/0.3937), 则 **dpi = √(宽度²+ 高度²)/屏幕尺寸**

因此，屏幕密度至关重要，屏幕密度怎么来的？厂商写入一个 system/build.prop 文件，有时还会写错，就我们一款华为平板，获取的屏幕密度是2，但是手工测量并按公式得到实际屏幕密度是1.56。导致我们的适配方案在那款平板就失效了。

本人一直在寻找可以一劳永逸的屏幕适配方案，今日头条是选定基准分辨率，基于设备屏幕分辨率计算出新的屏幕密度进行适配，保证所有设备的显示效果一致，完美避开上面那款设备的问题。

### 为什么看起来更小了？(头条方案跟最小宽度方案比较)

对的，跟原先的比起来，是更小了，包括图片更小，文字更小。这是为什么呢？

安卓有 mdpi、hdpi、xhdpi后缀的文件，具体使用有 drawable-mdpi、drawable-hdpi，或者mipmap-mdpi、mipmap-hdpi, 又或者 values-mdpi、values-hdpi, 这些都是安卓自带的屏幕适配方案，只是不太好用吗，经常出问题。那么，这些文件都是怎么使用的呢，这又涉及到了屏幕密度这个属性，关联如下：
| dpi             | 屏幕密度    |
| --------------- | ----------- |
| drawable-ldpi   | 0.75        |
| drawable-mdpi   | 1(baseline) |
| drawable-hdpi   | 1.5         |
| drawable-xhdpi  | 2           |
| drawable-xxhdpi | 3           |
| drawable-xxxdpi | 4           |

1. ldpi:mdpi:hdpi:xhdpi:xxhdpi:xxxdpi = 0.75:1:1.5:2:3:4 = 3:4:6:8:12:16

2. 上述比值乘以12，就是 36：48：72：144：192，刚好就是icon尺寸

3. 我们会看到，最小宽度适配方案，values-hdpi 的值是 values-mdpi 的值乘以 0.8

   ​	我们知道 `px = dp * density`，我们要适配的话需要确保 dp 不变去修改 density，而安卓默认 `density = dpi / 160`，其意思就是 1dp 有多少 px，也就是像素密度，我们开发是按照一份设计稿来做的，那么有没有什么办法来让 density 和设计稿尺寸做联系呢？假设我们设计稿是宽度是 1080px，资源放在 xxhdpi，那么我们宽度转换为 dp 就是 1080 / 3 = 360dp，要在不同设备上宽度都表现为 360dp，那么就需要修改其 `density = screenWidthPx / 360`，这样就满足了上述条件，而和 density 相关的还有 densityDpi、scaledDensity，我们根据 density 等比修改  densityDpi、scaledDensity 即可。



​		由于 API 26 及以上的 `Activity#getResources()#getDisplayMetrics()` 和 `Application#getResources()#getDisplayMetrics()` 是不同的引用，所以在 API 26 及以上适配是没有影响的，但在 API 26 以下 `Activity#getResources()#getDisplayMetrics()` 和 `Application#getResources()#getDisplayMetrics()` 是相同的引用，导致适配有问题，这里要感谢 @MirkoWu 提出的问题，后面会有解决方案。

​		如果我们以 xxhdpi 的 360dp 来适配的话，首先在 AS 中预览是个问题，在接入第三方 SDK 带有界面或者 View 的话会导致它的尺寸全然不对，因为我们那样适配后界面宽度只有 360dp，而第三方 SDK 中很有可能写的布局会超出 360dp，这便会引发新的问题，当然这也是有响应的解决之道，比如暂时取消适配，但我们有更好的方式，

 		着重推荐以 mdpi 为特例来适配，比如前面说到的 xxhdpi 的 360dp，那么在 mdpi 下就是 360 * 3 = 1080dp，**这样我们新建一个宽为 1080px 的 mdpi 设备（可以通过修改设备尺寸来达到 mdpi），然后切换为该设备来预览布局就完美解决了以上问题，**我们在写布局的时候设计图是 36px，那么我们直接就写 36dp 即可，设计图字体是 24px， 我们直接就写 24sp 即可，这样便可达到和设计图一致的效果。另外，图片资源放在需要适配的最高 dpi 下面即可，比如 `drawable-xxhdpi` 或者 `drawable-xxxhdpi`，这样在高清屏上也不会导致失真。

 