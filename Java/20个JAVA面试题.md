## 20个JAVA面试题

（一）**Java****部分**

1、**列举出****JAVA****中****6****个比较常用的包【天威诚信面试题】**

【参考答案】

java.lang;java.util;java.io;java.sql;java.awt;java.net;javax.swing

2、**JDK****中哪些类是不能继承的？****【信雅达面试题】**

【参考答案】

不能继承的是类是那些用final关键字修饰的类。一般比较基本的类型或防止扩展类无意间破坏原来方法的实现的类型都应该是final的。

3、**String****是最基本的数据类型吗****?****【天能智健面试题】**

【参考答案】

基本数据类型包括byte、int、char、long、float、double、boolean和short。

所以String不属于基本数据类型范畴内，但String属于最常见一种引用类型。

4、**short s1 = 1; s1 = s1 + 1;****有什么错****? short s1 = 1; s1 += 1;****有什么错****?****【博炎科技面试题】**

【参考答案】

对于short s1 = 1; s1 = s1 + 1;由于s1+1运算时会自动提升表达式的类型，所以结果是int型，再赋值给short类型s1时，编译器会提示错误，需要强制转换类型。

对于short s1 = 1; s1 += 1;由于+=是java语言规定的运算符，Java编译器会对它进行特殊处理，因此可以正确编译。

【分析】

主要考查几种基本数据类型在运算时的，由低到高会自动转换，而由高到低时会强制转换。

5、**Java****对象初始化顺序？【腾鹏科技面试题】**

【参考答案】

分为两种，一种是本类的初始化，一种是含有父类的初始化顺序。这里分开来说，

本类的初始化顺序是：静态变量、静态初始化块、变量、初始化块、构造函数

继承类的初始化顺序是：父类静态变量、父类静态初始化块、子类静态变量、子类静态初始块、父类变量、父类初始化块、父类构造函数、子类变量、子类初始化块、子类构造函数。

**说明：**

原则上回答全面的话，应该是完整的说出带有继承的这种类的初始化过程，下面有个步骤可以参考：

1.装载程序的时候首先找到的是它的基（父）类,如果有多层基（父）类则会一级一级的往上找最后找到根基（父）类。

2.执行根基础（父）类中的static初始化,再执行下一个衍生类中的static,依此类推,一直保持这个顺序。

3.此时类已经装载完毕,开始创建对象,所有的基本数据类型都会设成它们的默认值,对象句柄设为null

4.调用基础（父）类的构造方法,基础（父）类的构建采用与衍生类构造方法完全相同的处理过程。

5.构造方法初始完之后,进行变量的初始化。

6.执行构造方法中剩余的部分。

6、**写几个线程安全类，不安全的，支持排序的类名？【软通动力面试题】**

【参考答案】

Ø线程安全类：Vector、Hashtable、Stack。

Ø线程不安全的类：ArrayList、Linkedlist、HashSet、TreeSet、HashMap、TreeMap等。

Ø支持排序的类有HashSet、LinkedHashSet、TreeSet等（Set接口下的实现都支持排序）

【分析】

此题主要考查集合框架的知识。在集合框架中Collection接口为集合的根类型，提供集合操作的常用API方法，该接口下派生出两个子接口，一个是不支持排序的List接口，一个是有自身排序的Set接口，所以回答排序与不排序分别从两接口的实现中在作答。线程安全上来说，Vector类比同属于List接口的ArrayList要早，是一个线程安全的类，在JDK1.2以后才推出一个异步的ArrayList类，比Vector类效率高。同理Stack继承自Vector也线程安全的类，另外在在Map接口的实现在Hashtable也是个线程安全的类。

7、**哪几个方法可以实现一个线程？【上海华信面试题】**

【参考答案】

一是继承Thread，重写Thread类的方法run方法；另种是实现runnable接口并实现run方法。

【分析】

考查线程的基本实现，很多公司喜欢考查这方面知识，另外补充一下关于线程的run方法，在多线程API中启动一个线程是调用start()方法，线程进入就绪状态。

8、**STOP()****和****SUSPEND()****不推荐使用的原因？**

【参考答案】

stop()是因为它不安全。它会解除由线程获取的所有锁定，当在一个线程对象上调用stop()方法时，这个线程对象所运行的线程就会立即停止，假如一个线程正在执行：synchronized void { x = 3; y = 4;}由于方法是同步的，多个线程访问时总能保证x,y被同时赋值，而如果一个线程正在执行到x = 3;时，被调用了stop()方法，即使在同步块中，它也干脆地stop了，这样就产生了不完整的残废数据。而多线程编程中最最基础的条件要保证数据的完整性，所以请忘记线程的stop方法，以后我们再也不要说“停止线程”了。而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。

suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被"挂起"的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。

【分析】

9、**"=="****和****equals****方法有什么区别？****【中科软】**

【参考答案】

==操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存储的数值是否相同，要比较两个基本类型的数据或两个引用变量是否相等，只能用==操作符。

如果一个变量指向的数据是对象类型的，那么，这时候涉及了两块内存，对象本身占用一块内存（堆内存），变量也占用一块内存，例如Objet obj = new Object();变量obj是一个内存，new Object()是另一个内存，此时，变量obj所对应的内存中存储的数值就是对象占用的那块内存的首地址。对于指向对象类型的变量，如果要比较两个变量是否指向同一个对象，即要看这两个变量所对应的内存中的数值是否相等，这时候就需要用==操作符进行比较。

equals方法是用于比较两个独立对象的内容是否相同，就好比去比较两个人的长相是否相同，它比较的两个对象是独立的。例如，对于下面的代码：

String a=new String("foo");

String b=new String("foo");

两条new语句创建了两个对象，然后用a,b这两个变量分别指向了其中一个对象，这是两个不同的对象，它们的首地址是不同的，即a和b中存储的数值是不相同的，所以，表达式a==b将返回false，而这两个对象中的内容是相同的，所以，表达式a.equals(b)将返回true。

在实际开发中，我们经常要比较传递进行来的字符串内容是否等，例如，String input =…;input.equals(“quit”)，如果一个类没有自己定义equals方法，那么它将继承Object类的equals方法，Object类的equals方法的实现代码如下：

boolean equals(Object o){

return this==o;

}

这说明，如果一个类没有自己定义equals方法，它默认的equals方法（从Object类继承的）就是使用==操作符，也是在比较两个变量指向的对象是否是同一对象，这时候使用equals和使用==会得到同样的结果，如果比较的是两个独立的对象则总返回false。如果你编写的类希望能够比较该类创建的两个实例对象的内容是否相同，那么你必须覆盖equals方法，由你自己写代码来决定在什么情况即可认为两个对象的内容是相同的。

10、**静态变量和实例变量的区别？**

【参考答案】

在语法定义上的区别：静态变量前要加static关键字，而实例变量前则不加。

在程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。

例如，对于下面的程序，无论创建多少个实例对象，永远都只分配了一个staticVar变量，并且每创建一个实例对象，这个staticVar就会加1；但是，每创建一个实例对象，就会分配一个instanceVar，即可能分配多个instanceVar，并且每个instanceVar的值都只自加了1次。

public class VariantTest

{

public static int staticVar = 0;

public int instanceVar = 0;

public VariantTest()

{

staticVar++;

instanceVar++;

System.out.println(“staticVar=”+ staticVar +”,instanceVar=”+ instanceVar);

}

}

备注：这个解答除了说清楚两者的区别外，最后还用一个具体的应用例子来说明两者的差异，体现了自己有很好的解说问题和设计案例的能力，思维敏捷，超过一般程序员，有写作能力！

11、**构造器的名能不能和类的名字相同？**

【参考答案】

构造器的名称必须与类名相同。

【分析】

构造器或构造函数（有些书这样叫）主要用来对类的成员变量进行初始化，当类创建实例时调用。

12、**在一个主方法类可不可以调用一个非静态的方法？**

【参考答案】

可以调用。因为Java的主方法（main）方法本身也是static类型方法，一个static类型方法，发起对另一个static方法的调用没有问题。

【分析】

静态方法可以调用其它的静态方法，但是不能调用非静态方法，这个好比Java中的类变量与实例变量的关系。类变量是被所有类成员共享，而实例变量只被该实例共享，

13、**一个类中可不可以有****2****个公共的方法？**

【参考答案】

可以。Java中对公共方法的个数没有约束，但是对公共的类有约束，一个Java源文件中只能定义一个public类型的类。

14、**GC****是什么，为什么要使用它？【阿斯拓】**

【参考答案】

GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域，从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。

【分析】

15、**说一下垃圾回收的原理，可以直接从内存中回收吗****?**

【参考答案】

Java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收,因为Java语言规范并不保证GC一定会执行。回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。

【分析】

16、**Java****的异常有哪几种，有什么区别？**

【参考答案】

两大类，一般异常和运行时异常。一般异常，这些异常是在定义方法时声明抛出的，这些异常必需用try catch抛出，或throws处理，如果不处理，程序将编译失败。比如：IOException、FileNotFoundException、SQLException等。

运行时异常是程序运行时可能报出的异常。可以用try catch抓取，也可以不做任何处理。例如：NullPointerException异常就是一种比较常见的运行时异常。

【分析】

17、**switch****语句能否作用在****byte****上，能否作用在****long****上，能否作用在****String****上****?**

【参考答案】

在switch（表达式）中，括号表达式只能是一个整数表达式或者枚举常量（更大字体），整数表达式可以是int基本类型或Integer包装类型，由于，byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的。显然，long和String类型都不符合switch的语法规定，并且不能被隐式转换成int类型，所以，它们不能作用于swtich语句中。

18、**Integer****与****int****的区别？**

【参考答案】

int是java提供的8种原始数据类型之一，另外Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。int的默认值为0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况。

19、**Java Reflection****是什么****？****【】**

【参考答案】

JAVA反射，Reflection是Java程序开发语言的特征之一，它允许运行中的Java程序对自身进行检查，或者说"自审"，并能直接操作程序的内部属性。

【分析】

20、**写几个****java.lang.Object****类中的方法名称。**

【参考答案】

主要有equals()、toString()、getClass()、hashCode()、clone()、notify()、wait()、notify()方法。

【分析】

这种题能记多少个就说多少个，不一定要求你所有的都记住，但是要理解其中部分重要方法的含义和作用。

![img](https://gpic.qpic.cn/gbar_pic/jbII6ibGt34j4Jicibiaw8ibe4SkQBGgIicj6bR0ZKwKDrwjB89ea3XMxHAQ/0)